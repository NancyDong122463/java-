Java中的容器集合分为两大阵营，一个是Collection，一个是Map
Collection下分为Set，List，Queue
Set的常用实现类有HashSet，TreeSet等
List的常用实现类有ArrayList，LinkedList等
Queue的常用实现类有LinkedList，ArrayBlockingQueue等
Map下没有进一步分类，它的常用实现类有HashMap，ConcurrentHashMap等

List类面试题
谈谈ArrayList和LinkedList的区别
1、本质的区别来源于两者的底层实现：ArrayList的底层是数组，LinkedList的底层是双向链表。ArrayList随机查询快，linkedlist插入删除快。
2、数组拥有O(1)的查询效率，可以通过下标直接定位元素；链表在查询元素的时候只能通过遍历的方式查询，效率比数组低。
3、数组增删元素的效率比较低，通常要伴随拷贝数组的操作；链表增删元素的效率很高，只需要调整对应位置的指针即可。
4、以上是数组和链表的通俗对比，在日常的使用中，两者都能很好地在自己的适用场景发挥作用。
5、比如说我们常常用ArrayList代替数组，因为封装了许多易用的api，而且它内部实现了自动扩容机制，由于它内部维护了一个当前容量的指针size，直接往ArrayList中添加元素的时间复杂度是O(1)的，使用非常方便。
6、LinkedList常常被用作Queue队列的实现类，由于底层是双向链表，能够轻松地提供先入先出的操作。

谈谈ArrayList和Vector的区别
1、两者的底层实现相似，关键的不同在于Vector的对外提供操作的方法都是用synchronized修饰的，也就是说Vector在并发环境下是线程安全的，而ArrayList在并发环境下可能会出现线程安全问题。
2、由于Vector的方法都是同步方法，执行起来会在同步上消耗一定的性能，所以在单线程环境下，Vector的性能是不如ArrayList的
3、除了线程安全这点本质区别外，还有一个实现上的小细节区别：ArrayList每次扩容的大小为原来的1.5倍；Vector可以指定扩容的大小，默认是原来大小的两倍。

为什么ArrayList的elementData数组要加上transient修饰
1、由于ArrayList有自动扩容机制，所以ArrayList的elementData数组大小往往比现有的元素数量大，如果不加transient直接序列化的话会把数组中空余的位置也序列化了，浪费不少的空间。
2、ArrayList中重写了序列化和反序列化对应的writeObject和readObject方法，在遍历数组元素时，以size作为结束标志，只序列化ArrayList中已经存在的元素。

Set面试题
HashSet和TreeSet的区别
1.TreeSet背后的结构是TreeMap,也就是红黑树，能够实现自动排序。通过equals和compareTo方法进行内容的比较。
2.HashSet背后是HashMap,key是无序的，只能做外部排序。既然是Hash,那么就要重写其对象的hashCode和equals方法。

1.HashSet可以接受null值，有且只有一个
2.TreeSet默认不可以接受null值，会直接抛出空指针异常
3.set里没有重复数据，TreeSet里连虚无都没有

Map面试题
请介绍一下HashMap的实现原理
1、我们一般用HashMap存储key-value类型的数据，它的底层是一个数组，当我们调用put方法的时候，首先会对key进行计算得出一个hash值，然后根据hash值计算出存放在数组上的位置
2、这个时候我们会遇到两种情况：一是数组上该位置为空，可以直接放入数据；还有一种情况是该位置已经存放值了，这就发生了哈希冲突。
3、在现在使用较为普遍的JDK1.8中是这样处理哈希冲突的：先用链表把冲突的元素串起来，如果链表的长度达到了8，并且哈希表的长度大于64，则把链表转为红黑树。（在JDK1.7中没有转化为红黑树这一步，只用链表解决冲突）

HashMap是怎样确定key存放在数组的哪个位置的？
首先计算key的hash值，计算过程是：先得到key的hashCode（int类型，4字节），然后把hashCode的高16位与低16位进行异或，得到key的hash值。
接下来用key的hash值与数组长度减一的值进行按位与操作，得到key在数组中对应的下标。
追问：为什么计算key的hash时要把hashCode的高16位与低16位进行异或？（变式：为什么不直接用key的hashCode）
计算key在数组中的下标时，是通过hash值与数组长度减一的值进行按位与操作的。由于数组的长度通常不会超过2^16，所以hash值的高16位通常参与不了这个按位与操作。
为了让hashCode的高16位能够参与到按位与操作中，所以把hashCode的高16位与低16位进行异或操作，使得高16位的影响能够均匀稀释到低16位中，使得计算key位置的操作能够充分散列均匀。

为什么要把链表转为红黑树，阈值为什么是8？
在极端情况下，比如说key的hashCode()返回的值不合理，或者多个密钥共享一个hashCode，很有可能会在同一个数组位置产生严重的哈希冲突。

这种情况下，如果我们仍然使用使用链表把多个冲突的元素串起来，这些元素的查询效率就会从O(1)下降为O(N)。为了能够在这种极端情况下仍保证较为高效的查询效率，HashMap选择把链表转换为红黑树，红黑树是一种常用的平衡二叉搜索树，添加，删除，查找元素等操作的时间复杂度均为O(logN)

至于阈值为什么是8，这是HashMap的作者根据概率论的知识得到的。当key的哈希码分布均匀时，数组同一个位置上的元素数量是成泊松分布的，同一个位置上出现8个元素的概率已经接近千分之一了，这侧面说明如果链表的长度达到了8，key的hashCode()肯定是出了大问题，这个时候需要红黑树来保证性能，所以选择8作为阈值。

追问：为什么红黑树转换回链表的阈值不是7而是6呢？

如果是7的话，那么链表和红黑树之间的切换范围值就太小了。如果我的链表长度不停地在7和8之间切换，那岂不是得来回变换形态？所以选择6是一种折中的考虑。

请说一下HashMap的扩容原理

1、首先得到新的容量值和新的扩容阈值，默认都是原来大小的两倍。
2、然后根据新容量创建新的数组
3、最后把元素从旧数组中迁移到新数组中
在JDK1.7中，迁移数据的时候所有元素都重新计算了hash，并根据新的hash重新计算数组中的位置。
在JDK1.8中，这个过程进行了优化：如果当前节点是单独节点（后面没有接着链表），则根据该节点的hash值与新容量减一的值按位与得到新的地址。

如果当前节点后面带有链表，则根据每个节点的hash值与旧数组容量进行按位与的结果进行划分。如果得到的值为0，这些元素会被分配回原来的位置；如果得到的结果不为0，则分配到新位置，新位置的下标为当前位置下标加上旧数组容量。

为什么HashMap中适合用Integer，String这样的基础类型作为key？
因为这些基础类内部已经重写了hashCode和equals方法，遵守了HashMap内部的规范。
追问：如果要用我们自己实现的类作为key，要注意什么？
一定要重写hashCode()和equals()方法，而且要遵从以下规则：
equals()是我们判断两个对象是否相同的依据，如果我们重写了equals方法，用自己的逻辑去判断两个
对象是否相同，那么一定要保证：
两个equals()返回true的对象，一定要返回相同的hashCode。
这样，在HashMap的put方法中才能正确判断key是否相同。

为什么HashMap数组的长度是2的幂次方？
因为这样能够提高根据key计算数组位置的效率。
HashMap根据key计算数组位置的算法是：用key的hash值与数组长度减1的值进行按位与操作。
在我们正常人的思维中，获取数组的某个位置最直接的方法是对数组的长度取余数。但是如果被除数是2的幂次方，那么这个对数组长度取余的方法就等价于对数组长度减一的值进行按位与操作。
在计算机中，位运算的效率远高于取模运算，所以为了提高效率，把数组的长度设为2的幂次方。

HashMap与HashTable有什么区别？
在JDK1.7之前，两者的实现极为相似，最大的区别在于HashTable的方法都用synchronized关键字修饰起来了，表明它是线程安全的。
但是由于直接在方法上加synchronized关键字的同步效率较低，在并发情况下，官方推荐我们使用ConcurrentHashMap。
所以我们看到在JDK1.8中，官方甚至没有对HashTable进行链表转树这样的优化，HashTable已经不被推荐使用了。

请说一下ConcurrentHashMap的实现原理

在JDK1.7中ConcurrentHashMap采用了一种分段锁的机制，它的底层实现是一个segment数组，每个segment的底层结构和HashMap相似，也是数组加链表。
当对segment里面的元素进行操作之前，需要获得该segment独有的一把ReentrantLock。
ConcurrentHashMap如果不进行手动设置的话，默认有16个segment，可以支持16个线程对16个不同的segment进行并发写操作。
在JDK1.8之后摒弃了segment这种臃肿的设计，新的实现和HashMap非常相似，底层用的也是数组加链表加红黑树。
在新实现中，在put方法里使用了CAS + synchronized进行同步。如果插入元素的位置为空，则使用CAS进行插入。如果插入的位置不为空，则对当前位置的对象进行加锁，也就链表或红黑树的头节点，加锁后再进行后续的插入操作。

这样设计的好处是：
1、CAS是十分轻量的加锁操作，如果能够直接插入，用CAS能够大幅度节省加锁的开销。
2、如果发生冲突，只用锁住当前位置的头结点，理论上数组的长度有多大，并发操作的线程数就能有多少，比原来只能有16个线程效率更高。
